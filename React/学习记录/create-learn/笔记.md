# Effect Hook

Effect Hook：用于在函数组件中处理副作用

副作用：一个函数应该比较纯粹，应该只用于处理数据
- 具有副作用的实例：
  1. ajax 请求
  2. 计时器
  3. 其他异步操作
  4. 更改DOM对象
  5. 本地存储
  6. 其他会对外部产生影响的操作

**注意为什么不要在一些生命周期中存在一些副作用的操作？**
在涉及服务端渲染的时候，会出现部分生命周期会被运行两次的问题，
如果存在一些副作用操作，那么就会操作两次，比如数据获取、计时器重复等等问题，
所有我们最好只在 componentDidMount、componentDidUpdate、componentWillUnMount 中存在副作用操作

现在 Effect HOOK 旨在于解决开发人员在不该存在副作用的函数中禁止副作用操作

**细节**
1. 副作用函数的运行时间点，实在页面完成真实UI渲染后。因此它的执行是异步的，所有不会阻塞浏览器
2. 触发 Effect HOOK 运行的条件：componentDidMount 和 componentDidUpdate 生命周期运行，就会触发 Effect HOOK，在完成UI渲染后运行
   1. 与类组件中的componentDidMount和componentDidUpdate的区别
      1. componentDidMount和componentDidUpdate，更改了真实DOM，但是用户还没有UI更新，同步的
      2. useEffect中的副作用函数，是在更改了真实DOM，并且用户已经看到了UI更新，异步的
3. 每个函数组件中，可以多次使用useEffect（运行顺序按照注册顺序执行），但不要放入判断或循环等代码块中
4. useEffect 中的副作用函数，可以有返回值，返回值必须是一个函数，该函数叫做清理函数
   1. 该函数运行时间点，在每次运行副作用函数之前
   2. 首次渲染不会运行
   3. 组件被销毁时一定会运行 
5. useEffect 函数，可以传递第二个参数（可选）
   1. 第二个参数，是一个数组
   2. 数组中记录该副作用的依赖数据
   3. 当组件重新渲染后，只有依赖数据与上一次不一样的时候，才会执行副作用
   4. 所以，当传递了依赖数据之后，如果数据没有发生变化
      1. 副作用函数仅在第一次渲染后运行
      2. 清理函数仅在卸载组件后运行后
6. 副作用函数中，如果使用了函数上下文中的变量，则会导致副作用函数中的数据不会实时变化
7. 副作用函数在每次注册时，会覆盖掉之前的副作用函数，因此，尽量保证副作用函数稳定，否则可能会出现不可控因素