# 利用中间件 进行副作用处理

- redux-thunk

thunk允许action是一个带有副作用的函数，当action是一个函数被分发时，thunk会阻止action继续向后提交

thunk回想函数中传递三个参数：
- dispatch： 来自于store.dispatch
- getState: 来自于store.getState
- extra: 来自于用户设置的额外参数

- redux-promise
如果action是一个promise，则会等待promise完成，将完成的结果作为action触发，
如果action不是一个promise，则判断其payload是否是一个promise，如果是，等待promise完成，
然后将得到的结果作为payload的值触发



- redux-saga


# 迭代器和可迭代协议

> 解决副作用的 redux 中间件
> redux-thunk：需要改动action,可接收action是一个函数
> redux-promise:需要改动action，可接收action是一个promise对象，或action的payload是一个promise对象
> 以上两个中间件，会导致action或action创建函数不再纯净
> redux-saga将解决这样的问题，它不仅可以保持action、action创建函数、reducer的纯净，而且可以模块化的方式解决副作用，并且功能非常强大
> redux-saga是建立在es6的生成器基础上的，要熟练的使用saga，必须理解生成器
> 要理解生成器，必须先理解迭代器和可迭代协议

## 迭代器

JS语言规定，如果一个对象具有next方法，并且next方法满足一定的约束，则该对象是一个迭代器。

next方法的约束：该方法返回一个一个对象
  - 该对象有两个属性
    - value：下一个数据的值， any类型
    - done：是否已经迭代完成，bool类型

通过迭代器的next方法，可以依次取出数据，并可以根据返回的done属性，判定是否迭代结束

## 迭代器创建函数 iterator creator

它是指一个函数，调用该函数后，返回一个迭代器，则该函数称之为迭代器创建函数，有的时候可以简称为迭代器函数。

## 可迭代协议

es6 中出现了 for-of 循环，该循环就是用于迭代某个可迭代对象的。
因此，for-of 要求迭代对象必须是一个可迭代对象（满足可迭代协议）


可迭代协议适用于约束一个对象的，如果一个对象满足下面的规范，则该对象满足可迭代协议，也称之为该对象是可以被迭代的。

可迭代协议的约束如下：

1. 对象必须有一个知名符号属性（Symbol.iterator）
2. 该属性必须是一个无参迭代器创建函数

## for-of循环的原理

调用对象的[Symbol.iterator]方法，得到一个迭代器。不断调用next方法，将得到的value值，传入循环中，直到done为false为止

# 生成器 generator
## generator

生成器：有构造函数Generator创建的函数，该对象既是一个迭代器，同时，又是一个可迭代对象（满足可迭代协议的对象）

**注意：Generator构造函数，不提供给开发者使用，仅作为JS引擎内部使用**

## generator function
生成器函数（生成器创建函数）：该函数用于创建一个生成器

ES6 新增一个特殊的函数，叫做生成器函数，只要在函数名与function 之间写上一个*号，该函数就会自动返回一个生成器

生成器函数的特点：
  1. 调用生成器函数，会返回一个生成器，而不是执行函数体（因为，生成器函数的函数体执行，受到生成器控制）
  2. 每当调用了生成器的next方法，生成器的函数体会从上一次yield的位置（或开始位置）运行到下一个yield位置
    1. yield关键字只能在生成器内部使用，不可以在普通函数内部使用
    2. 它表示暂停，并返回一个当前迭代的数据
    3. 如果没有下一个yield，到了函数结束，则生成器的next方法得到的结果中的done为true
  3. yield关键字后面的数据，会作为本次yield迭代返回的数据value值
  4. 生成器函数的返回值，会作为最后一次迭代的done为true时的value值
     1. 如果在done为true后，再次调用next，value值为undefiend
  5. 生成器调用next的时候，可以传递参数，该参数会作为生成器函数体上一次yield表达式的值。
     1. 生成器第一次调用next阿含糊时，传递参数没有任何意义，因为参数是作为上一次yield位置的返回值
  6. 生成器带有throw方法，该方法与next的效果相等，惟一的区别在于：
     1. next方法传递的参数会被返回成一个正常的值
     2. throw方法传递的参数是一个错误对象，会导致生成器内部发生一个错误
  7. 生成器带有一个return方法，该方法会直接结束生成器函数
  8. 若需要在生成器内部调用其他生成器，
     1. 注意：如果直接调用一个生成器函数，得到的是一个生成器，不会有其他操作，因为返回的是一个生成器，其内部代码不会运行
     2. 如果 使用 ```yield* 生成器函数``` 那么，就会进入到该生成器函数创建的生成器内部中执行代码流程
     3. 当进入的生成器结束时，这个生成器函结束返回的值作为外部yield位置的值

**生成器函数完全受到其生成器控制**

# redux-saga

- 纯净
- 强大
- 灵活

在saga任务中，如果yield了一个普通数据，saga不做任何处理，仅仅将数据传递给yield表示式（把得到的数据放到next的参数中），因此，在sage中，yield一个普通数据没有什么意义

saga需要你在yield后买你放上一些合适的saga指令（saga effects），如果放的是指令，saga中间件会根据不同的指令进行特殊处理，以控制整个流程

**一旦saga任务完成（生成器函数运行完成），则sage中间件一定结束**

**指令前面必须使用yield，以确保该指令返回结果被saga控制**

- take指令：【阻塞】监听某个action的type，如果该action发生了，则会进行下一步处理，take指令仅监听一次，yield得到的是完整的action对象
- all指令：【阻塞】该函数传入一个数组，数组中放入生成器，saga会等待所有的生成器全部完成后才会进一步处理
- takeEvery指令：不断的监听某个actio，当某个action到达之后，运行一个函数，takeEvery永远不会结束当前的生成器，使用通配符可以匹配所有action，但action的类型必须是字符串
- delay指令：【阻塞】阻塞指定的毫秒数
- put指令：用于重新触发action，相当于dispatch一个action
- call指令：【可能阻塞】用于副作用（通常是异步）函数调用，传递参数方式与原生一致，如果需要在call中绑定this，第一个参数写成一个数组，数组第一项为this指向，第二项为函数
  - ```call([this,fn], arg) or call({context: this, fn: fn}, arg)```
- apply指令：【可能阻塞】用于副作用（通常是异步）函数调用，传递参数、绑定this与原生一致
- select指令：用于取出当前仓库中的数据，有一个参数为函数，用于筛选数据
- cps指令：【可能阻塞】用于调用哪些传统的回调方式的异步函数,在call等中都是使用promise 得到return值，如果是回调模式，那么就没有return值，这种情况下使用cps处理回调模式
- fork指令：用于开启一个新的生成器任务，该任务不会阻塞，该函数需要传递一个生成器函数
- cancel指令：用于取消一个或多个任务，实际上，取消的实现原理，是利用generator.return。cancel可以不传递参数，如果不传递参数，则取消当前任务
- takeLastest指令：功能和takeEvery一致，只不过，会自动取消之前开启的任务
- cancelled指令：判断当前任务线是否被取消掉
- race指令：【阻塞】竞赛，可以传递多个指令，当其中任何一个指令结束后，会直接结束，与Promise.rece类似