# 利用中间件 进行副作用处理

- redux-thunk

thunk允许action是一个带有副作用的函数，当action是一个函数被分发时，thunk会阻止action继续向后提交

thunk回想函数中传递三个参数：
- dispatch： 来自于store.dispatch
- getState: 来自于store.getState
- extra: 来自于用户设置的额外参数

- redux-promise
如果action是一个promise，则会等待promise完成，将完成的结果作为action触发，
如果action不是一个promise，则判断其payload是否是一个promise，如果是，等待promise完成，
然后将得到的结果作为payload的值触发


# 迭代器和可迭代协议

> 解决副作用的 redux 中间件
> redux-thunk：需要改动action,可接收action是一个函数
> redux-promise:需要改动action，可接收action是一个promise对象，或action的payload是一个promise对象
> 以上两个中间件，会导致action或action创建函数不再纯净
> redux-saga将解决这样的问题，它不仅可以保持action、action创建函数、reducer的纯净，而且可以模块化的方式解决副作用，并且功能非常强大
> redux-saga是建立在es6的生成器基础上的，要熟练的使用saga，必须理解生成器
> 要理解生成器，必须先理解迭代器和可迭代协议

- redux-saga


## 迭代器

JS语言规定，如果一个对象具有next方法，并且next方法满足一定的约束，则该对象是一个迭代器。

next方法的约束：该方法返回一个一个对象
  - 该对象有两个属性
    - value：下一个数据的值， any类型
    - done：是否已经迭代完成，bool类型

通过迭代器的next方法，可以依次取出数据，并可以根据返回的done属性，判定是否迭代结束

## 迭代器创建函数 iterator creator

它是指一个函数，调用该函数后，返回一个迭代器，则该函数称之为迭代器创建函数，有的时候可以简称为迭代器函数。

## 可迭代协议

es6 中出现了 for-of 循环，该循环就是用于迭代某个可迭代对象的。
因此，for-of 要求迭代对象必须是一个可迭代对象（满足可迭代协议）


可迭代协议适用于约束一个对象的，如果一个对象满足下面的规范，则该对象满足可迭代协议，也称之为该对象是可以被迭代的。

可迭代协议的约束如下：

1. 对象必须有一个知名符号属性（Symbol.iterator）
2. 该属性必须是一个无参迭代器创建函数

## for-of循环的原理

调用对象的[Symbol.iterator]方法，得到一个迭代器。不断调用next方法，将得到的value值，传入循环中，直到done为false为止