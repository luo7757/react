# 渲染原理 在app.jsx 中查看代码

渲染：生成用于显示的对象，以及将这些对象形成真实DOM元素

- React元素：React Elment，通过React.createElement创建(语法糖：JSX)
  - 例如：在render中的使用JSX书写的标签就会转为 React 元素
    - ```<div><h1></h1></div>``` React 标签元素
    - ```<App />``` React 组件
- React节点：装门用于渲染到UI界面的对象，React会通过React元素，创建React节点,ReactDOM一定是通过React节点来进行渲染的
  - 节点类型：
    - React DOM节点（ReactDOMComponent）：创建该节点的React元素类型是一个字符串
    - React 组件节点（Componsite：混合节点）：创建该节点的React元素类型是一个函数或是一个类 
    - React TextNode节点：由字符串、数字创建的节点
    - React empty节点：由null、undefined、false、true创建的节点
    - React 数组节点：该节点由一个数组创建
- 真实DOM：通过document.createElement创建的dom元素


## 首次渲染（新节点渲染）
1. 通过参数的值创建节点
2. 根据不同的节点，做不同的事情
   1. TextNode：通过document.createTextNode 创建真实的文本节点
   2. 空节点：什么都不做，但react dom树中存在，真实dom中不存在
   3. 数组节点：遍历数组，将数组每一项递归创建节点（回到第一步进行反复操作，直到遍历结束）
   4. DOM 节点：通过document.createElement创建真实DOM对象，然后遍历对应React元素的child属性，递归操作（回到第一步进行反复操作，直到遍历结束）
   5. 组件节点：
      1. 函数组件：调用函数（该函数必须返回一个可以生成节点的内容），将该函数的返回结果，递归生成节点，直到遍历结束
      2. 类组件：
         1. 创建该类的实例
         2. 立即调用对象的生命周期方法: static getDerivedStateFromProps
         3. 运行该对象的 render 方法，拿到节点对象（将该节点递归操作，回到第一步进行反复操作，直到遍历结束）
         4. 将该组件的componentDidMount加入到执行队列（先进先出），当整个虚拟dom树全部构建完毕，并且将真实的DOM对象挂载到容器之后，运行该对列中的函数
3. 生成出虚拟DOM树之后，将该树保存起来，以便后续使用
4. 将之前生成的真实dom对象，添加到挂载容器中

## 更新节点

更新的场景：
1. 重新调用ReactDOM.render，完全重新生成节点数
   1. 触发根节点更新
2. 在类组件中调用setState，数据变动，重新生成虚拟该节点的为起始点向下依次生成虚拟dom树

**节点的更新**
- 如果调用的是ReactDOM.render， 进入根节点的对比（diff）更新
- 如果调用的是setState
  1. 运行生命周期函数 static getDerivedStateFromProps 
  2. 运行生命周期函数 shouldComponentUpdate ，如果该函数返回了false，终止当前流程
  3. 运行render，得到一个新的节点，进入该新的节点的对比更新 **对比更新**
  4. 将生命周期函数 getSnapshotBeforeUpdate 加入执行队列，以待将来执行
  5. 将生命周期函数 componentDidUpdate 加入执行对立，以待将来执行

后续步骤：
  1. 更新虚拟DOM树
  2. 完成真实DOM更新
  3. 依次调用执行队列中的 componentDidMount
  4. 依次调用执行队列中的 getSnapshotBeforeUpdate 
  5. 依次调用执行队列中的 componentDidUpdate

**比对更新**

将新生成的节点，对比之前的虚拟DOM中的节点，发现差异，完成更新

问题：对比之前DOM树中的哪个节点

React 为了提高效率，做出以下假设

1. 假设节点不会出现层次的移动（对比时，直接找到旧树中对应位置的节点进行对比）
2. 不同的节点类型会生成不同的结构 （节点类型会影响结构）
   1. 相同的节点类型：节点本身类型相同，如果是由React元素生成，type值还必须一致
   2. 其他的，都属于不相同的节点类型
3. 多个兄弟通过唯一标识（key）来确定对比的新节点

key值的作用：用于通过旧节点，寻找对应的新节点，如果莫格旧节点有key值，则其更新时，会寻找相同层级中的相同key值的节点，进行对比
 
#### 找到了对比的目标

判断节点类型是否一致
- **一致**
   1. 根据不同的节点类型，做不同的事情
      **空节点**：不做任何事情
      **DOM节点**：
        1. 直接使用之前的真实DOM对象
        2. 将其属性的变化记录下，以待将来统一完成更新（现在不会真正的变化）
        3. 遍历该新的React元素的子元素，**递归对比更新**
      **文本节点**：
        1. 直接重用之前的真实DOM对象
        2. 记录变化的文本数据，以待将来更新
      **组件节点**：
       1. **函数组件**：直接重新调用函数，进入递归对比更新虚拟DOM树
       2. **类组件**：
          1. 重用之前的实例
          2. 调用生命周期方法 getDerivedStateFromProps
          3. 调用生命周期方法 shouldComponentUpdate，若该方法返回false，终止
          4. 运行render，得到新的节点对象，进入**递归对比更新**
          5. 将该对象的 getSnapshotBeforeUpdate 加入队列
          6. 将该对象的 componentDidUpdate 加入队列
      **数组节点**：遍历数组进行**递归对比更新**
- **不一致**
整体上，卸载旧的节点，重新创建新的节点

**创建新节点**

进入新节点的创建


**卸载旧节点**
1. **文本节点、DOM节点、数组节点、空节点、函数组件节点**：直接放弃旧节点
2. **类组件节点**：
   1. 直接放弃该节点
   2. 调用该节点的 componentWillUnMount 函数
   3. 递归卸载子节点
  
**在开发中，尽量避免出现结构相同，但节点类型不同，这会导致该节点下面所有元素都会重新生成新的DOM元素，如果节点类型一致，那么就会重用之前的DOM元素**

#### 没有找到对比的目标

新的DOM树中有节点被删除

新的DOM树中有节点添加
- 创建新加入的节点
- 卸载多余的节点
