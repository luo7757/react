# 常见应用 - 实现导航守卫

导航守卫：当离开一个页面，进入另一个页面时，触发的事件

history 对象

- listen ：添加一个监听器，监听地址的变化，当地址发生变化时，会调用传递的函数
  - 参数：函数，运行时间点：发生在即将跳转新页面时,
    - 参数1：location对象，记录当前的地址信息
    - 参数2：action，一个字符串，表示进入该地址的方式
      - POP：出栈（栈中指针移动）
        - 通过点击浏览器后退、前进
        - 调用history.go
        - 调用history.goBack
        - 调用history.goForward
      - PUSH：入栈
        - history.push
      - REPLACE：替换
        - history.replace
  - 返回结果：函数，可以调用该函数取消监听
- block：设置一个阻塞，并同时设置阻塞消息，当页面发生跳转时，会进入阻塞，并将阻塞消息传递至路由根组件 BrowserRouter/HashRouter... 的 一个方法getUserComfirmation中
阻塞只能写一个，因为history对象是一个全局的对象，全局共享，写了之后所有Route组件都会阻塞
  - 两个写法
    - 1 传递一个字符串
    - 2 传递一个函数，函数会有两个参数
      - location 当前地址栏参数
      - action 进入方式
  - 注意 在 block 书写处，获取this.props.location 是跳转前的地址， 传递函数时，参数location 是想要跳转的组件的 location值 ，对应 from，to


路由根组件(BrowserRouter/HashRouter...)：
- getUserComfirmation
  - 参数：函数 
    - 参数1：阻塞消息
      - 字符串消息
      - 函数，函数返回的结果是一个字符串
        - 参数1： location对象
        - 参数2： action 对象
    - 参数2：在子路由中使用了 history.block('xxxxx')，在进入子路由时，会运行阻塞，不写就不会运行

