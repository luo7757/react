# umijs 简介

- 插件化
- 开箱即用
- 约定式路由

## 全局安装umi

提供了一个命令行工具：umi，通过该命令可以对umi工程进行操作

> umi还可以使用对应的脚手架

- dev : 使用开发模式启动工程

## 约定式路由
umi对路由的处理，主要通过两种方式：
1. 约定式：使用约定好的文件夹和文件，来代表页面，umi会根据开发者书写的页面，生成路由配置，成为配置式路由，最终结果都会是配置式路由，约定式只是写法不同。
2. 配置式：直接书写路由配置文件

- umi约定，工程中的pages文件夹中存放的是页面。如果工程包含src目录，则src/pages是页面文件夹
- umi约定，页面的文件名，相对于pages的路径就是路由中的配置的路由地址，不分大小写,
  比如 /pages/test.tsx 那么路径就是 /test
- umi约定，如果页面的文件名是index，则可以省略文件名（注意避免文件名和当前目录的文件夹名重名）
- umi约定：如果src/layouts目录存在，则该目录中的表示的是全局的通用布局，布局中的children则会添加具体的页面。
- umi约定，如果pages文件夹中包含layout.js，则layout.js所在的目录及其所有的子目录中页面，共用该布局
- umi约定，如果pages/404.js存在，那么在找不到组件的时候，就显示该404组件（开发模式中无效，开发时会提供相关开发信息， 在生产模式中才有效）
- 使用$开头的名称，会产生动态路由。

### 路由跳转

- 跳转链接（组件）：导入```umi/link or umi/navlink```, 使用方法和react-route-dom一致
- 代码跳转（route）：导入```umi/route```，里面就是路由相关的跳转方式 

### 路由信息的获取
所有的页面/布局组件，都会通过属性，收到下面的属性

- match： 等同于react-router 的match
- history：等同于reatc-router的history（history.location.query被封装成了一个对象，使用的是query-string库进行的封装 ）
- location：等同于react-router的location（location.query被封装成了一个对象，使用的是query-string库进行的封装）
- route：对应的路由配置

如果需要在普通组件中获取路由信息，则需要shiyongwithRouter封装，可以通过```umi/withRouter```导入

## 配置式路由

当使用了路由配置后，约定式路由全部失效

两种方式书写umi配置：
1. 使用根目录下的文件```.umirc.js```
2. 使用根目录下的文件```config/config.js```

进行路由配置时，每个配置就是一个匹配规则，并且，每个配置是一个对象,对象中的某些属性，会直接成为Route组件的属性

注意： 
- component配置项，需要填写页面组件的路径，路径是相对于pages文件夹的路径，在react-route中是使用组件
- 如果配置项没有exact，则会自动添加exact为true
- 每一个路由配置，可以添加任何属性
- Routes属性是一个数组，数组中的每一项是一个组件路径，路径相对于项目根目录，当匹配到路由后，会转而渲染该路由指定的组件Routes，并会将component组件作为children放到匹配的组件中